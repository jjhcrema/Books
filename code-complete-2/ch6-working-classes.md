# Chapter 6. Working Classes

## 6.1 Class Foundations: Abstract Data Types (ADTs)
- ADT란 데이터와 데이터를 처리하는 명령의 집합이다
  - ADT를 잘 이해하고 있어야 올바른 class 제작이 가능하다 (안그러면 껍데기뿐)

### Example of the Need for an ADT
- 폰트 스타일을 변경하는 프로그램의 예
  - 직접적으로 데이터를 수정하도록 작성하는 경우 프로그램의 많은 곳에서 비슷한 코드를 작성할 수 밖에 없다

### Benefits of Using ADTs
- 상세 구현을 숨길 수 있다
  - 설정값의 디테일이 변경되더라도 최소 범위만 수정하면 된다
- 변경사항이 전체 프로그램에 영향을 미치지 않는다
- 인터페이스에 더 많은 정보를 표현할 수 있다
  - 단순 설정값은 무엇을 의미하는지 모호하게 할 수 있다
- 성능 향상이 쉽다
- 명백히 옳게 작성할 수 있다
  - 단순 설정값은 실수를 유발할 수 있지만, 명백한 인터페이스는 실수를 줄여준다
- 코드 자체로 문서화가 될 수 있다
- 프로그램 전체에 걸쳐 데이터를 넘겨줄 필요가 없다
- 저수준의 구조를 구현하는 것보다 실제의 모습들을 구현하기 쉬워진다

### More Examples of ADTs
- 핵반응기의 쿨링시스템 구현의 예
  - 인터페이스만 알면, 내부 구현사항과 한계를 알 필요가 없다
- 가이드라인
  - 데이터 타입을 ADT로 구성하거나 사용하라
  - 범용 오브젝트를 ADT로 다루라
    - File operations
  - 아주 간단한 것들도 ADT로 다루라
    - self-documenting, easy to change
  - 저장된 매체와 독립적으로 참조하라
    - 어디에 저장될지는 나중에 바뀔 수도 있다. RateFile -> reateTable or rates

### Handling Multiple Instances of Data with ADTs in Non-Object-Oriented Environments
- 비객체지향 환경에서 여러 인스턴스를 관리하기 위해서 (굳이...)
  - 인스턴스 구별자를 가지거나
  - 매 루틴마다 ADT를 사용하기 위한 데이터를 제공하거나
  - 잘 관리되는 암묵적인 인스턴스를 사용하거나

### ADTs and Classes
- 클래스는 상속과 다형성을 지원하는 ADT이다

## 6.2 Good Class Interfaces

### Good Abstraction
- 클래스 인터페이스에서 일관된 추상화 수준을 제공하라
  - 하나의 클래스에서는 하나의 ADT만 구현하라
- 클래스가 어떤 추상화를 구현하는지 이해하고 적절한 것을 선택하라
- 적절한 반대 작업을 제공하라
- 관계 없는 정보는 다른 클래스로 이동하라
- 인터페이스간의 문법을 만들지 마라 (순서 강제 등)
- 인터페이스 추상화가 흐려지지 않도록 하라
  - 명확했던 것을 헝크러뜨리지 않도록
- 기존의 인터페이스와 일관되지 않는다면 추가하지 마라
- 추상화와 응집력(cohesion)을 함께 고려하라

### Good Encapsulation
- 클래스와 멤버의 접근을 최소화하라
- 멤버 데이터를 공개적으로 노출하지 말아라
- 비공개된 상세 구현내용을 인터페이스로 노출하지 말아라
- 인터페이스가 어떻게 사용될지 가정하지 마라
- friend class를 피하라
  - 복잡도를 증가시킨다
- public만 사용한다고 해서 public으로 두지 마라
- 인터페이스간 문법성이 강하지 않게 하라
- 커플링이 너무 강해지는지 확인하라

## 6.3 Design and Implementation Issues

### Containment ("has a" Relationships)
- member data로 구현
- private 상속을 통해 구현
- data member가 7개보다 많다면 클래스를 분리하는 것을 생각해보라

### Inheritance ("is a" Relationships)
- 다른 클래스의 특별화 개념
- 코드 중복을 피할 수 있고, 데이터 집중화를 할 수 있다
- 언제 상속을 해야 할까?
  - 각각의 멤버 루틴에 기본 구현사항이 있고, 재정의가 가능한가?
  - 각각의 데이터 멤버를 사용할 수 있는가?
- public 상속
  - base class와 동일한 인터페이스로 동작하지 않는다면 상속은 잘못된 접근
- 상속과 금지를 위한 디자인 및 문서화
  - non-virtual in C++, final in Java ... 상속을 막는 디자인
- LSP 준수
  - 서브 클래스는 부모 클래스의 인터페이스로 동작 가능해야 한다
  - 부모 클래스에 정의된 인터페이스는 같은 동작을 해야 한다
- 상속하려고 하는 것만 상속하라
  - override 가능한 것과 아닌 것을 구분하라
- non-overridable member function을 override하지 마라
- 공통된 것들은 가능한 높은 부모 클래스로 옮겨라
- 인스턴스가 하나밖에 없다면 의심해보라
- 상속된 클래스가 하나밖에 없다면 의심해보라
- override한 루틴에서 아무것도 안 한다면 의심해보라
- 너무 깊은 상속을 피하라
- 타입 체킹보다는 다형성을 추구하라
- 모든 데이터는 private하게..
  - 상속은 캡슐화를 깬다
  - 부모의 데이터를 접근하려면 protected accessor를 사용하라

### Multiple Inheritance
- 다중 상속은 편리함과 동시에 매우 위험
  - 1950년대의 전기톱과 같다..안전이 보장되지 않음
- "mixins"를 사용하라

### Why Are There So Many Rules for Inheritance?
- 데이터를 공유하지만 가공하지 않는다면, 공통 오브젝트를 둬라
- 같은 행동을 공유하지만 데이터는 공유하지 않을 때는 공통 루틴을 정의하는 공통 기본 클래스에서 상속하라
- 행동과 데이터를 공유하면 둘 모두를 정의한 기본 클래스에서 상속하라
- 기본 클래스가 인터페이스를 제어하도록 할 때 상속하라

### Member Functions and Data
- 멤러 루틴을 가급적 적게 두라
- 원하지 않는 암묵적인 member function을 허용하지 마라
- 여러 클래스에서 호출되는 수를 최소한으로 유지하라
  - 이게 항상 어려움. 코드 전체를 파악해야 함
- 다른 클래스에서 간접 호출을 최소화하라
- 다른 클래스와의 협업을 최소화하라
- 가능하면 생성자에서 데이터를 초기화하라
- singleton 속성은 private constructor를 강제하라
- deep copy를 선호하라
  - 참조를 복사하면 위험한 때가 있다 (루비는 그럴 일이 없을 듯)
  - smart pointer

## 6.4 Reasons to Create a Class
- 실세계의 오브젝트를 모델링하기 위해
- 추상 오브젝트를 모델링하기 위해
- 복잡도를 줄이기 위해
  - 정보를 숨겨서 굳이 생각하지 않아도 되게 함
- 복잡성을 격리하기 위해
  - 복잡한 알고리즘의 구현 방식을 신경쓰지 않아도 됨
- 세부 구현을 숨기기 위해
  - 외부에서 변경하지 못하도록
- 변경으로 인한 효과를 제한하기 위해
- 전역 데이터를 숨기기 위해
- 많은 파마미터 전달을 쉽게 하기 위해
- 집중화된 제어를 하기 위해
- 코드를 재사용하기 위해
- 프로그램 제품군을 계획하기 위해
- 관련된 명령을 패키징하기 위해
- 특정 리팩토링을 하기 위해

### Classes to Avoid
- 전지전능한 클래스는 피하라
- 관련없는 클래스는 제거하라
- 동사형 클래스는 피하라

## 6.5 Language-Specific Issues
- 각 언어별 내용들..패스

## 6.6 Beyond Classes: Packages
- 라이브러리 같은 것
- 네이밍 잘해라 등등
